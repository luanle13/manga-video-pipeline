{% extends "base.html" %}

{% block title %}Queue - Manga Video Pipeline{% endblock %}

{% block content %}
<h1>Video Job Queue</h1>

<!-- Filter and Controls -->
<div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <div style="display: flex; gap: 1rem; align-items: center;">
            <label for="statusFilter" style="margin: 0;">Filter by Status:</label>
            <select id="statusFilter" style="width: 200px;">
                <option value="">All</option>
                <option value="pending">Pending</option>
                <option value="fetching">Fetching</option>
                <option value="scripting">Scripting</option>
                <option value="tts">TTS</option>
                <option value="rendering">Rendering</option>
                <option value="awaiting_review">Awaiting Review</option>
                <option value="uploading">Uploading</option>
                <option value="completed">Completed</option>
                <option value="failed">Failed</option>
            </select>
        </div>
        <div style="color: #666; font-size: 0.9rem;">
            Auto-refreshing every 30 seconds
        </div>
    </div>

    <!-- Jobs Table -->
    <table id="jobs-table">
        <thead>
            <tr>
                <th>Job ID</th>
                <th>Manga Title</th>
                <th>Status</th>
                <th>Created</th>
                <th>Updated</th>
                <th>Video</th>
                <th>YouTube Link</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td colspan="8" style="text-align: center; padding: 2rem;">Loading...</td>
            </tr>
        </tbody>
    </table>

    <!-- Pagination -->
    <div class="pagination">
        <button id="prevPage" onclick="previousPage()" disabled>← Previous</button>
        <span id="pageInfo" style="padding: 0.5rem 1rem;">Page 1</span>
        <button id="nextPage" onclick="nextPage()" disabled>Next →</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let currentPage = 1;
    let currentFilter = '';
    let totalPages = 1;
    let refreshInterval;

    // Check if video is available for download based on job status
    // Only show download when video is confirmed to exist (after rendering completes)
    function hasVideoAvailable(status) {
        const videoStatuses = ['awaiting_review', 'uploading', 'completed'];
        return videoStatuses.includes(status);
    }

    // Load jobs
    async function loadJobs() {
        try {
            const params = new URLSearchParams({
                page: currentPage,
                page_size: 20
            });

            if (currentFilter) {
                params.append('status_filter', currentFilter);
            }

            const response = await fetch(`/api/queue?${params}`, {
                credentials: 'include'
            });

            if (!response.ok) {
                throw new Error('Failed to load jobs');
            }

            const data = await response.json();
            const tbody = document.querySelector('#jobs-table tbody');

            if (data.jobs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666;">No jobs found</td></tr>';
                updatePaginationControls(0);
                return;
            }

            tbody.innerHTML = data.jobs.map(job => `
                <tr>
                    <td><code>${truncateId(job.job_id)}</code></td>
                    <td>${job.manga_title}</td>
                    <td><span class="badge ${job.status}">${job.status}</span></td>
                    <td>${formatDateTime(job.created_at)}</td>
                    <td>${formatDateTime(job.updated_at)}</td>
                    <td>
                        ${hasVideoAvailable(job.status)
                            ? `<a href="#" onclick="downloadVideo('${job.job_id}'); return false;" title="Download video from S3">Download</a>`
                            : '-'}
                    </td>
                    <td>
                        ${job.youtube_url
                            ? `<a href="${job.youtube_url}" target="_blank">Watch</a>`
                            : '-'}
                    </td>
                    <td>
                        ${job.status === 'failed'
                            ? `<button class="btn btn-sm" onclick="retryJob('${job.job_id}')">Retry</button>`
                            : job.status === 'awaiting_review'
                                ? `<div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
                                     <button class="btn btn-sm btn-success" onclick="uploadToYouTube('${job.job_id}')" title="Upload to YouTube">Upload</button>
                                     <button class="btn btn-sm btn-danger" onclick="skipUpload('${job.job_id}')" title="Skip upload">Skip</button>
                                   </div>`
                                : '-'}
                    </td>
                </tr>
            `).join('');

            updatePaginationControls(data.total);
        } catch (error) {
            console.error('Error loading jobs:', error);
            showToast('Failed to load jobs', 'error');
        }
    }

    // Update pagination controls
    function updatePaginationControls(total) {
        const pageSize = 20;
        totalPages = Math.ceil(total / pageSize);

        document.getElementById('prevPage').disabled = currentPage === 1;
        document.getElementById('nextPage').disabled = currentPage >= totalPages || totalPages === 0;
        document.getElementById('pageInfo').textContent = totalPages > 0
            ? `Page ${currentPage} of ${totalPages}`
            : 'No results';
    }

    // Pagination functions
    function previousPage() {
        if (currentPage > 1) {
            currentPage--;
            loadJobs();
        }
    }

    function nextPage() {
        if (currentPage < totalPages) {
            currentPage++;
            loadJobs();
        }
    }

    // Get CSRF token helper
    async function getCsrfToken() {
        const csrfResponse = await fetch('/settings', {
            credentials: 'include'
        });
        const csrfHtml = await csrfResponse.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(csrfHtml, 'text/html');
        return doc.querySelector('input[name="csrf_token"]')?.value;
    }

    // Retry job
    async function retryJob(jobId) {
        if (!confirm('Are you sure you want to retry this job?')) {
            return;
        }

        try {
            const csrfToken = await getCsrfToken();
            if (!csrfToken) {
                throw new Error('Failed to get CSRF token');
            }

            const formData = new FormData();
            formData.append('csrf_token', csrfToken);

            const response = await fetch(`/api/queue/${jobId}/retry`, {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });

            const data = await response.json();

            if (response.ok) {
                showToast('Job retry initiated successfully', 'success');
                loadJobs();
            } else {
                showToast(data.detail || 'Failed to retry job', 'error');
            }
        } catch (error) {
            console.error('Error retrying job:', error);
            showToast('Failed to retry job', 'error');
        }
    }

    // Download video
    async function downloadVideo(jobId) {
        try {
            const response = await fetch(`/api/queue/${jobId}/video-url`, {
                credentials: 'include'
            });

            if (!response.ok) {
                const data = await response.json();
                showToast(data.detail || 'Failed to get download URL', 'error');
                return;
            }

            const data = await response.json();
            // Open download URL in new tab
            window.open(data.download_url, '_blank');
            showToast('Download started', 'success');
        } catch (error) {
            console.error('Error downloading video:', error);
            showToast('Failed to download video', 'error');
        }
    }

    // Upload to YouTube
    async function uploadToYouTube(jobId) {
        if (!confirm('Upload this video to YouTube?')) {
            return;
        }

        try {
            const csrfToken = await getCsrfToken();
            if (!csrfToken) {
                throw new Error('Failed to get CSRF token');
            }

            const formData = new FormData();
            formData.append('csrf_token', csrfToken);

            const response = await fetch(`/api/queue/${jobId}/upload`, {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });

            const data = await response.json();

            if (response.ok) {
                showToast('YouTube upload initiated', 'success');
                loadJobs();
            } else {
                showToast(data.detail || 'Failed to start upload', 'error');
            }
        } catch (error) {
            console.error('Error triggering upload:', error);
            showToast('Failed to trigger upload', 'error');
        }
    }

    // Skip YouTube upload
    async function skipUpload(jobId) {
        if (!confirm('Skip YouTube upload? The video will remain in S3 but won\'t be uploaded.')) {
            return;
        }

        try {
            const csrfToken = await getCsrfToken();
            if (!csrfToken) {
                throw new Error('Failed to get CSRF token');
            }

            const formData = new FormData();
            formData.append('csrf_token', csrfToken);

            const response = await fetch(`/api/queue/${jobId}/skip-upload`, {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });

            const data = await response.json();

            if (response.ok) {
                showToast('Upload skipped, job marked as completed', 'success');
                loadJobs();
            } else {
                showToast(data.detail || 'Failed to skip upload', 'error');
            }
        } catch (error) {
            console.error('Error skipping upload:', error);
            showToast('Failed to skip upload', 'error');
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        // Load initial jobs
        loadJobs();

        // Status filter listener
        document.getElementById('statusFilter').addEventListener('change', (e) => {
            currentFilter = e.target.value;
            currentPage = 1; // Reset to first page
            loadJobs();
        });

        // Auto-refresh every 30 seconds
        refreshInterval = setInterval(loadJobs, 30000);
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (refreshInterval) {
            clearInterval(refreshInterval);
        }
    });
</script>
{% endblock %}
